#include <iostream>

#include "IntroSort.h"

int main()
{
	 int arr[17] = {7, 12, 65, 23, 1, 4, 8, 13, 0, 10, 77, 67, 128, 6, 99, 4535, 400};
	 int size = sizeof(arr) / sizeof(arr[0]);

	  for (auto &&i : arr)
	  {
	      std::cout << i << " ";
	  }
	  std::cout << std::endl;

	  IntroSort::Sort(arr, arr + size, [](int a, int b) { return a < b; });

	  for (auto&& i : arr)
	  {
		  std::cout << i << " ";
	  }
	  std::cout << std::endl;
}

/*
Описание решения:

Каждый алгоритм сортировки имеет свои плюсы и минусы. Т.е. хорошо работают на различных входных наборах.
Для этого задания было приянято реализовать комбинацию из нескольких сортировок под  названием IntroSort.
Intro sort работает как: Начинается сортировка с применения алгоритма Quicsort, если глубина рекурсии доходит до
значения 2 * log(size of array), далее сортировка переключается на Insertionsort если количество значений в массиве меньше 16.
Благодаря такому решению представляется возможность избежать худшый случай алгоритма Quicksort который является O(n^2) на O(nlog(n)).
Так же решается проблема Quicksort большого постоянного коэффициента на маленьком наборе значений.

Благодаря обьединению нескольких алгоритмов сортировки появилась возможность избежать слабых мест и подчеркнуть сильные стороны ипользуемых алгоритмов.

*/